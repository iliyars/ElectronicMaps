using ElectronicMaps.Application.DTO;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ElectronicMaps.Application.Stores
{
    /// <summary>
    /// Хранилище анализированных компонентов в памяти.
    /// Компоненты группируются по строковому ключу (например, коду формы).
    /// Все компоненты могуть храняиться по ключу "all"
    /// 
    /// Хранилище потокобезопасно и генерирует событие <see cref="Changed"/> при любых изменениях.
    /// </summary>
    public interface IComponentStore : IDisposable
    {

        bool HasUnsavedChanges { get; }
        /// <summary>
        /// Собитие, возникающее при любых изменениях в хранилище.
        /// Вызывается после операций добавления, удаления, замены, загрузки и сохранения.
        /// В аргументах события передаётся тип изменения, ключ (если применимо)
        /// и текущее общее количество компонентов во всех группах.
        /// </summary>
        event EventHandler<StoreChangedEventArgs>? Changed;

        /// <summary>
        /// Возвращает все компоненты из хранилища, независимо от группировки.
        /// 
        /// Реализация возвращает копию списка. Изменения возвращаемого списка не влияют на хранилище.
        /// </summary>
        /// <returns>Список компонентов. Может быть пустым но никогда не null</returns>
        IReadOnlyList<AnalyzedComponentDto> GetAll();

        /// <summary>
        /// Возвращает компоненты, относящиеся к указанному коду формы.
        /// 
        /// Код формы трактуется как ключ группировки (например "FORM_4", "FORM_64").
        /// </summary>
        /// <param name="formCode">
        /// Код формы (строковый ключ группы компонентов). 
        /// </param>
        /// <returns>
        /// Список компонентов соответсвующей формы. Может быть пустым но никогда не null
        /// Возвращаются копии компонентов из хранилища (изменения возвращаемого списка не влияют на хранилище).
        /// </returns>
        IReadOnlyList<AnalyzedComponentDto> GetByComponentForm(string formCode);
        /// <summary>
        /// Полностью заменяет содержимое хранилища новым набором компонентов.
        /// 
        /// Типичный сценарий использования — первичная загрузка перечня компонентов
        /// после анализа нового XML-файла. Реализация может сохранить этот набор,
        /// например, под специальным ключом (условно "ALL"), но детали ключа
        /// являются внутренней реализацией.
        /// </summary>
        /// <param name="components">
        /// Последовательность компонентов, которая должна стать единственным
        /// содержимым хранилища. Значения с пустым <see cref="AnalyzedComponentDto.CleanName"/>
        /// могут игнорироваться реализацией.
        /// </param>
        void ReplaceAll(IEnumerable<AnalyzedComponentDto> components);

        /// <summary>
        /// Заменяет список компонентов для конкретной формы (группы).
        /// 
        /// Остальные формы (другие ключи) не затрагиваются. Метод удобно использовать
        /// при операциях редактирования, объединения и разбиения компонентов в рамках одной формы,
        /// а также при реализации Undo/Redo на уровне списка формы.
        /// </summary>
        /// <param name="formCode">
        /// Код формы (строковый ключ группы), для которой требуется заменить список компонентов.
        /// Не должен быть пустой.
        /// </param>
        /// <param name="components">
        /// Новый набор компонентов для указанной формы. Старый список для этой формы
        /// полностью заменяется. Значения с пустым <see cref="AnalyzedComponentDto.CleanName"/>
        /// могут игнорироваться реализацией.
        /// </param>
        void ReplaceForm(string formCode, IEnumerable<AnalyzedComponentDto> components);
        /// <summary>
        /// Добавляет один компонент в список указанной формы (группы).
        /// Если для данного кода формы ещё нет списка, он будет создан.
        /// Сам <paramref name="component"/> может содержать или не содержать свой
        /// <see cref="AnalyzedComponentDto.ComponentFormCode"/> — реализация может
        /// проигнорировать его и использовать только параметр <paramref name="formCode"/>
        /// как ключ.
        /// </summary>
        /// <param name="formCode">
        /// Код формы (строковый ключ группы), в список которой нужно добавить компонент.
        /// Не должен быть пустой или состоять только из пробелов.
        /// </param>
        /// <param name="component">
        /// Добавляемый компонент. Не должен быть <c>null</c>.</param>
        void AddToForm(string formCode, AnalyzedComponentDto component); 


        /// <summary>
        /// Удаляет компоненты с указанным <paramref name="cleanName"/> ТОЛЬКО из заданной формы.
        /// 
        /// В отличие от метода <see cref="Remove(string)"/>, затрагивает только одну группу
        /// (один код формы) и не влияет на остальные.
        /// </summary>
        /// <param name="formCode">
        /// Код формы (строковый ключ группы), из которой нужно удалить компоненты.
        /// </param>
        /// <param name="cleanName">
        /// Значение <see cref="AnalyzedComponentDto.CleanName"/>, по которому
        /// выполняется поиск и удаление. Сравнение, как правило, регистронезависимое.
        /// Если строка пустая или состоит из пробелов, метод ничего не делает.
        /// </param>
        void RemoveFromForm(string formCode, string name);

        /// <summary>
        /// Удаляет компоненты с заданным <paramref name="key"/> (обычно CleanName)
        /// из всех групп/форм в хранилище.
        /// 
        /// Если требуется удалить компонент только из одной формы, используйте
        /// <see cref="RemoveFromForm(string, string)"/>.
        /// </summary>
        /// <param name="key">
        /// Значение <see cref="AnalyzedComponentDto.CleanName"/>, по которому выполняется удаление.
        /// Сравнение, как правило, регистронезависимое. Если строка пустая, удаление не выполняется.
        /// </param>
        /// <returns>
        /// <c>true</c>, если хотя бы один компонент был удалён; иначе <c>false</c>.
        /// </returns>
        /// <summary>
        /// Удалить компонент по ключу
        /// </summary>
        /// <param name="key"></param>
        bool Remove(string key);

        /// <summary>
        /// Полностью очищает хранилище, удаляя компоненты всех форм (включая общий список).
        /// </summary>
        void Clear();

        void MarkClean();

        /// <summary>
        /// Асинхронно сохраняет текущие компоненты хранилища в JSON-файл.
        /// 
        /// Как правило, сохраняется плоский список компонентов без группировки,
        /// а при последующей загрузке реализация сама распределяет их по внутренним ключам.
        /// </summary>
        /// <param name="path">
        /// Путь к файлу. Если <c>null</c>, используется путь по умолчанию,
        /// заданный реализацией (например, во временной директории).
        /// </param>
        /// <param name="ct">
        /// Токен отмены операции.
        /// </param>
        Task SaveAsync(string? path = null, CancellationToken ct = default);

        /// <summary>
        /// Асинхронно загружает компоненты из JSON-файла в хранилище.
        /// 
        /// Текущее содержимое хранилища очищается и заменяется загруженными данными.
        /// Если файл по указанному пути отсутствует, метод тихо завершается
        /// без изменений состояния хранилища.
        /// </summary>
        /// <param name="path">
        /// Путь к файлу. Если <c>null</c>, используется путь по умолчанию,
        /// заданный реализацией (например, во временной директории).
        /// </param>
        /// <param name="ct">
        /// Токен отмены операции.
        /// </param>
        Task LoadAsync(string? path = null, CancellationToken ct = default);



    }
}
